---
phase: 02-sentinel-data-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models.py
  - src/queries/__init__.py
  - src/queries/incidents.py
  - src/queries/alerts.py
  - src/projections.py
  - src/sentinel_client.py
  - tests/test_models.py
  - tests/test_queries.py
  - tests/test_sentinel_client.py
autonomous: true
requirements: [QUERY-01, QUERY-02, QUERY-03]

must_haves:
  truths:
    - "query_incidents() returns Incident dataclasses filtered by severity threshold and time window, wrapped in metadata envelope"
    - "Incident dataclass includes entity_count field per user decision (populated in detail view, defaults to 0 in list view)"
    - "get_incident_detail() by number returns incident with related alerts and entities, with entity_count populated from entity results"
    - "get_incident_detail() by name (string) returns matching incidents via case-insensitive substring"
    - "query_alerts() returns Alert dataclasses filtered by severity and time range, wrapped in metadata envelope"
    - "Timestamps in results include human-readable relative strings (e.g. '2 hours ago')"
    - "Partial results set truncated=True in metadata and include partial_error message"
    - "Failed queries return QueryError with code, message, and retry_possible flag"
    - "incident_list projection includes entity_count field"
  artifacts:
    - path: "src/models.py"
      provides: "Dataclass definitions for Incident (with entity_count), Alert, TrendPoint, EntityCount, QueryMetadata, QueryResult, QueryError, plus format_relative_time utility"
      contains: "class Incident"
    - path: "src/queries/__init__.py"
      provides: "Template registry, severity_filter(), build_query(), TIME_WINDOWS, TEMPLATE_TIMEOUTS"
      exports: ["TEMPLATE_REGISTRY", "severity_filter", "build_query", "TIME_WINDOWS"]
    - path: "src/queries/incidents.py"
      provides: "KQL templates for list_incidents, get_incident_by_number, get_incident_by_name, get_incident_alerts, get_incident_entities"
      contains: "TEMPLATES"
    - path: "src/queries/alerts.py"
      provides: "KQL templates for list_alerts"
      contains: "TEMPLATES"
    - path: "src/projections.py"
      provides: "Per-query-type field projection configs including entity_count in incident views"
      contains: "PROJECTIONS"
    - path: "src/sentinel_client.py"
      provides: "SentinelClient class with query_incidents, get_incident_detail, query_alerts methods"
      contains: "class SentinelClient"
    - path: "tests/test_sentinel_client.py"
      provides: "Unit tests with mocked LogsQueryClient for incident and alert queries"
      contains: "def test_"
  key_links:
    - from: "src/sentinel_client.py"
      to: "src/queries/__init__.py"
      via: "import TEMPLATE_REGISTRY, build_query, severity_filter, TIME_WINDOWS"
      pattern: "from src\\.queries import"
    - from: "src/sentinel_client.py"
      to: "src/models.py"
      via: "import Incident, Alert, QueryResult, QueryError, QueryMetadata"
      pattern: "from src\\.models import"
    - from: "src/sentinel_client.py"
      to: "src/projections.py"
      via: "import PROJECTIONS for post-query field filtering"
      pattern: "from src\\.projections import"
    - from: "src/queries/__init__.py"
      to: "src/queries/incidents.py"
      via: "merges incidents.TEMPLATES into TEMPLATE_REGISTRY"
      pattern: "from src\\.queries import incidents"
---

<objective>
Build the data model layer, KQL template registry, projection configs, and SentinelClient with incident and alert query methods. This is the foundational infrastructure for all Sentinel data access.

Purpose: Establish the complete query pipeline -- from KQL templates through parameter substitution to typed dataclass results wrapped in metadata envelopes. Incident and alert queries cover the three most common SOC analyst use cases.

Output: src/models.py, src/queries/ package, src/projections.py, src/sentinel_client.py with incident/alert methods, and comprehensive unit tests.
</objective>

<execution_context>
@C:/Users/AlexSandstrom/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/AlexSandstrom/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sentinel-data-access/02-RESEARCH.md
@.planning/phases/02-sentinel-data-access/02-CONTEXT.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/config.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data models, KQL template registry, and projection configs</name>
  <files>
    src/models.py
    src/queries/__init__.py
    src/queries/incidents.py
    src/queries/alerts.py
    src/projections.py
    tests/test_models.py
    tests/test_queries.py
  </files>
  <action>
Create the foundational data layer for all Sentinel queries. This task builds the types, templates, and configuration that the SentinelClient will consume.

**src/models.py** -- Define all dataclasses and utilities:
- `QueryMetadata(total: int, query_ms: float, truncated: bool, partial_error: str | None = None)` -- metadata envelope
- `QueryResult(metadata: QueryMetadata, results: list[Any])` with `to_dict()` that serializes results recursively
- `QueryError(code: str, message: str, retry_possible: bool)` with `to_dict()`
- `Incident` dataclass with fields: `number` (int), `title` (str), `severity` (str), `status` (str), `created_time` (datetime), `last_modified_time` (datetime), `description` (str, default=""), `owner` (str, default=""), `alert_count` (int, default=0), `entity_count` (int, default=0), `closed_time` (datetime | None), `first_activity_time` (datetime | None), `last_activity_time` (datetime | None), `incident_url` (str, default=""), `classification` (str, default=""), `classification_reason` (str, default=""), `labels` (list[str] | None, default=None), `created_time_ago` (str, default=""), `last_modified_time_ago` (str, default=""). Include `to_dict()` that converts datetimes to ISO strings. NOTE: `entity_count` is a user-locked decision from CONTEXT.md ("Incident lists include summary + counts: ... entity count ..."). It defaults to 0 in the list view because SecurityIncident has no native entity data -- entity counts are computed from SecurityAlert.Entities which requires a cross-table join that would be too expensive for list queries. The field is populated with the actual count in `get_incident_detail()` from the entity sub-query results.
- `Alert` dataclass with fields: `name` (str), `display_name` (str), `severity` (str), `status` (str), `time_generated` (datetime), `description` (str, default=""), `tactics` (str, default=""), `techniques` (str, default=""), `provider_name` (str, default=""), `compromised_entity` (str, default=""), `system_alert_id` (str, default=""), `time_generated_ago` (str, default=""). Include `to_dict()`.
- `TrendPoint(timestamp: datetime, count: int, severity: str = "")` with `to_dict()`
- `EntityCount(entity_type: str, entity_name: str, count: int)` with `to_dict()`
- `format_relative_time(dt: datetime) -> str` utility: "just now" (<60s), "N minutes ago", "N hours ago", "yesterday at H:MM AM/PM", "N days ago" (<7d), "Mon DD, YYYY" (>=7d). Handle naive datetimes by assuming UTC. Use `%I:%M %p` for cross-platform compatibility (not `%-I` which fails on Windows).

**src/queries/__init__.py** -- Central registry and utilities:
- `SEVERITY_ORDER = ["Informational", "Low", "Medium", "High"]` -- NO Critical (confirmed by research)
- `severity_filter(min_severity: str = "Informational") -> str` -- returns KQL-safe comma-separated string of severities at or above threshold. Invalid severity defaults to all (index 0). Example: `severity_filter("Medium")` -> `"'Medium','High'"`
- `TIME_WINDOWS` dict mapping window names to `{"timespan": timedelta, "kql_ago": str}`. Include: `last_1h`, `last_24h`, `last_3d`, `last_7d`, `last_14d`, `last_30d` (per research discretionary recommendation).
- `DEFAULT_LIMITS` dict with per-query-type defaults: `incident_list: 20`, `alert_list: 20`, `incident_detail_alerts: 50`, `alert_trend: 365`, `top_entities: 10`. `MAX_LIMITS` dict with hard caps: `incident_list: 100`, `alert_list: 100`, `incident_detail_alerts: 200`, `alert_trend: 365`, `top_entities: 50`.
- `TEMPLATE_TIMEOUTS` dict: 60s for simple queries (list_incidents, get_incident_by_number, get_incident_by_name, list_alerts, get_incident_alerts, get_incident_entities), 180s for aggregation queries (alert_trend, alert_trend_total, top_entities). `DEFAULT_TIMEOUT = 60`.
- `build_query(template_name: str, **params) -> str` -- looks up template in `TEMPLATE_REGISTRY`, validates all required placeholders are provided, applies defaults, calls `.format(**params)` for substitution. Raises `ValueError` for unknown template or missing required params.
- `TEMPLATE_REGISTRY` -- merged dict from all domain modules (incidents.TEMPLATES, alerts.TEMPLATES). trends and entities TEMPLATES will be added in Plan 02.

**src/queries/incidents.py** -- KQL templates dict `TEMPLATES`:
- `list_incidents`: Query SecurityIncident with `ago({time_range})` filter, `summarize arg_max(LastModifiedTime, *) by IncidentNumber` for dedup, `Severity in ({severity_filter})`, project all needed fields (IncidentNumber, Title, Severity, Status, CreatedTime, LastModifiedTime, Owner, AlertIds, Description, FirstActivityTime, LastActivityTime), order by CreatedTime desc, `take {limit}`. NOTE: No entity count in this KQL -- SecurityIncident has no Entities column. Entity count is computed only in the detail view via get_incident_entities sub-query.
- `get_incident_by_number`: Filter by `IncidentNumber == {incident_number}`, dedup with arg_max, project full detail fields including ClosedTime, Labels, Classification, ClassificationReason, IncidentUrl, AlertIds.
- `get_incident_by_name`: Dedup first, then `Title contains "{incident_name}"`, project full detail fields, `take {limit}`.
- `get_incident_alerts`: Use `let` statement to get AlertIds from incident by number, `mv-expand AlertId = AlertIds`, join to SecurityAlert via SystemAlertId, project alert fields.
- `get_incident_entities`: Same let statement for AlertIds, join to SecurityAlert, `parse_json(Entities)`, `mv-expand Entity`, extract EntityType and EntityName with `case()` for account/ip/host/url/file types, `distinct EntityType, EntityName`.

**src/queries/alerts.py** -- KQL templates dict `TEMPLATES`:
- `list_alerts`: Query SecurityAlert with `ago({time_range})`, `AlertSeverity in ({severity_filter})` (NOTE: use `AlertSeverity` NOT `Severity` -- critical pitfall from research), project AlertName, DisplayName, AlertSeverity, Status, TimeGenerated, Description, Tactics, Techniques, ProviderName, CompromisedEntity, SystemAlertId, order by TimeGenerated desc, `take {limit}`.

**src/projections.py** -- Define `PROJECTIONS` dict keyed by view name:
- `incident_list`: number, title, severity, status, created_time, alert_count, entity_count, last_modified_time, created_time_ago, last_modified_time_ago (entity_count included per user decision -- will be 0 in list view, populated in detail view)
- `incident_detail`: number, title, severity, status, description, created_time, last_modified_time, closed_time, owner, alert_count, entity_count, labels, classification, classification_reason, first_activity_time, last_activity_time, incident_url, created_time_ago, last_modified_time_ago
- `alert_list`: name, display_name, severity, status, time_generated, tactics, provider_name, compromised_entity, time_generated_ago
- Define `apply_projection(data: dict, view: str) -> dict` helper that filters a dict to only include keys present in the projection for the given view. Returns unmodified dict if view not found (defensive).

**tests/test_models.py** -- Test dataclass serialization:
- Test Incident.to_dict() converts datetimes to ISO strings and includes entity_count field
- Test QueryResult.to_dict() serializes nested Incident results
- Test QueryError.to_dict()
- Test format_relative_time() with: just now, minutes ago, hours ago, yesterday, days ago, older dates

**tests/test_queries.py** -- Test template registry and builder:
- Test severity_filter() for each threshold level (Informational through High)
- Test severity_filter() with invalid input defaults to all severities
- Test build_query() renders a template with correct parameter substitution
- Test build_query() raises ValueError for unknown template name
- Test build_query() raises ValueError for missing required parameters
- Test TIME_WINDOWS contains expected keys and correct timedelta/kql_ago pairs
- Test TEMPLATE_REGISTRY contains all expected template names
  </action>
  <verify>
Run `pytest tests/test_models.py tests/test_queries.py -v` -- all tests pass.
Run `python -c "from src.models import Incident, Alert, QueryResult, QueryError; print('models OK')"` -- imports succeed.
Run `python -c "from src.models import Incident; i = Incident(number=1, title='t', severity='High', status='New', created_time=__import__('datetime').datetime.now(), last_modified_time=__import__('datetime').datetime.now()); assert hasattr(i, 'entity_count'); print('entity_count field present')"` -- entity_count field exists on Incident.
Run `python -c "from src.queries import TEMPLATE_REGISTRY, build_query, severity_filter, TIME_WINDOWS; print(len(TEMPLATE_REGISTRY), 'templates')"` -- prints template count.
Run `python -c "from src.projections import PROJECTIONS, apply_projection; assert 'entity_count' in PROJECTIONS['incident_list']; assert 'entity_count' in PROJECTIONS['incident_detail']; print('entity_count in projections OK')"` -- entity_count present in both incident projections.
  </verify>
  <done>
All dataclasses defined with to_dict() serialization. Incident dataclass includes entity_count field (int, default=0) per user decision. KQL template registry contains 6 templates (list_incidents, get_incident_by_number, get_incident_by_name, get_incident_alerts, get_incident_entities, list_alerts). build_query() validates and renders templates. severity_filter() implements threshold model. TIME_WINDOWS maps 6 predefined windows. Projections define 3 views, with entity_count included in both incident_list and incident_detail projections. All model and query tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SentinelClient with incident and alert query methods</name>
  <files>
    src/sentinel_client.py
    tests/test_sentinel_client.py
  </files>
  <action>
Build the SentinelClient class that executes KQL templates via LogsQueryClient and returns typed results.

**src/sentinel_client.py** -- Full SentinelClient implementation:

`class SentinelClient`:
- `__init__(self, settings: Settings)`: Store `settings.sentinel_workspace_id`, create `DefaultAzureCredential()`, create `LogsQueryClient(credential)`. Accept optional `client` parameter for test injection (if provided, skip credential/client creation).
- Private `_execute_query(self, query: str, timespan: timedelta, server_timeout: int) -> tuple[list, bool, str | None, float]`: Call `self._client.query_workspace()` with `workspace_id`, `query`, `timespan`, `server_timeout`, `include_statistics=True`. Check `response.status`:
  - `LogsQueryStatus.SUCCESS`: Extract tables, compute query_ms from `response.statistics["query"]["executionTime"] * 1000` (handle missing stats gracefully), return `(tables, False, None, query_ms)`.
  - `LogsQueryStatus.PARTIAL`: Extract `response.partial_data`, `response.partial_error`, compute query_ms, return `(tables, True, f"{error.code}: {error.message}", query_ms)`.
  - Catch `HttpResponseError`: Return `QueryError` with `code=e.error.code` or `"http_error"`, `message=str(e)`, `retry_possible=True` for 429/5xx and `False` otherwise.
  - Catch general `Exception`: Return `QueryError` with `code="unknown"`, `message=str(e)[:500]`, `retry_possible=False`.

- Private `_parse_incidents(self, tables, is_detail: bool = False) -> list[Incident]`: Parse LogsTable rows into Incident dataclasses. Map Sentinel column names to dataclass fields: IncidentNumber->number, Title->title, Severity->severity, Status->status, CreatedTime->created_time, LastModifiedTime->last_modified_time, Description->description, AlertIds->alert_count (len of parsed JSON array), Owner->owner (extract from dynamic JSON: `json.loads(owner).get("assignedTo", "")` if string, else ""). Set `entity_count=0` for all parsed incidents (SecurityIncident table has no entity data natively; entity_count is populated later by get_incident_detail from entity sub-query results). Compute `created_time_ago` and `last_modified_time_ago` using `format_relative_time()`. Handle None/missing fields defensively. For detail view, also map: ClosedTime, Labels (parse JSON array), Classification, ClassificationReason, FirstActivityTime, LastActivityTime, IncidentUrl.

- Private `_parse_alerts(self, tables) -> list[Alert]`: Parse LogsTable rows into Alert dataclasses. Map: AlertName->name, DisplayName->display_name, AlertSeverity->severity (NOT Severity), Status->status, TimeGenerated->time_generated, Description->description, Tactics->tactics, Techniques->techniques, ProviderName->provider_name, CompromisedEntity->compromised_entity, SystemAlertId->system_alert_id. Compute `time_generated_ago`.

- Private `_parse_entities(self, tables) -> list[dict]`: Parse entity rows into simple dicts with `entity_type` and `entity_name` keys. (Used by get_incident_detail for incident entities.)

- `query_incidents(self, time_window="last_24h", min_severity="Informational", limit=20) -> QueryResult | QueryError`: Validate time_window in TIME_WINDOWS (return QueryError if invalid). Clamp limit to MAX_LIMITS["incident_list"]. Build query via `build_query("list_incidents", time_range=..., severity_filter=severity_filter(min_severity), limit=limit)`. Execute via `_execute_query`. Parse results. Apply projection "incident_list". Wrap in QueryResult with metadata. Note: entity_count will be 0 for all incidents in list view.

- `get_incident_detail(self, incident_ref: int | str) -> QueryResult | QueryError`: If `incident_ref` is int, use "get_incident_by_number" template. If str, use "get_incident_by_name" template with limit=10. Execute incident query, parse as detail. Then execute "get_incident_alerts" and "get_incident_entities" for the incident number(s) found. **After receiving entity results, set `entity_count` on each incident** to the count of entities returned by `get_incident_entities` for that incident (i.e., `len(entities)`). Return composite result: `{"incidents": [...], "alerts": [...], "entities": [...]}` structure within QueryResult. Apply "incident_detail" projection to incidents.

- `query_alerts(self, time_window="last_24h", min_severity="Informational", limit=20) -> QueryResult | QueryError`: Same pattern as query_incidents but for alerts. Use "list_alerts" template. Parse with `_parse_alerts`. Apply "alert_list" projection.

**tests/test_sentinel_client.py** -- Unit tests with mocked LogsQueryClient:
- Create a `MockLogsTable` class that mimics LogsTable: has `.columns` (list of str) and `.rows` (list of MockRow). `MockRow` supports both index and column-name access.
- Create a `MockResponse` class with `.status`, `.tables`, `.statistics`, `.partial_data`, `.partial_error`.
- Create a `mock_sentinel_client` fixture that injects a mocked LogsQueryClient into SentinelClient (using the optional `client` parameter).
- Test `query_incidents()` returns QueryResult with correct Incident dataclasses and metadata envelope, including entity_count=0 in list view.
- Test `query_incidents()` with severity filter returns only matching severities in the KQL query string.
- Test `get_incident_detail()` by number returns incident with alerts and entities, and entity_count on the incident is populated from the entity sub-query count.
- Test `get_incident_detail()` by string name uses contains template.
- Test `query_alerts()` returns QueryResult with Alert dataclasses.
- Test partial results set `truncated=True` and include `partial_error` in metadata.
- Test HTTP error returns QueryError with appropriate code and retry_possible flag.
- Test invalid time_window returns QueryError.
- Test limit clamping to hard cap.
  </action>
  <verify>
Run `pytest tests/test_sentinel_client.py -v` -- all tests pass.
Run `pytest -v` -- all tests pass (including existing config tests and new model/query tests from Task 1).
Run `ruff check src/ tests/` -- no linting errors.
Run `python -c "from src.sentinel_client import SentinelClient; print('client OK')"` -- import succeeds.
  </verify>
  <done>
SentinelClient class implemented with query_incidents(), get_incident_detail(), and query_alerts() methods. Each method: validates parameters, builds KQL via template registry, executes via LogsQueryClient, parses LogsTable rows into typed dataclasses, applies projection, wraps in metadata envelope. entity_count defaults to 0 in _parse_incidents() and is populated from entity sub-query results in get_incident_detail(). Partial results handled with truncated flag. Errors returned as structured QueryError objects. All unit tests pass with mocked LogsQueryClient. No ruff linting errors.
  </done>
</task>

</tasks>

<verification>
1. `pytest -v` passes all tests (existing config tests + new model/query/client tests)
2. `ruff check src/ tests/` reports no errors
3. `python -c "from src.sentinel_client import SentinelClient; from src.models import Incident, Alert, QueryResult; from src.queries import TEMPLATE_REGISTRY; print(f'{len(TEMPLATE_REGISTRY)} templates registered')"` succeeds
4. All dataclass to_dict() methods produce JSON-serializable output
5. Incident dataclass has entity_count field, incident_list and incident_detail projections include entity_count
6. severity_filter("Medium") returns "'Medium','High'" (threshold model, no Critical)
7. build_query() raises ValueError for unknown templates and missing params
</verification>

<success_criteria>
- SentinelClient.query_incidents() returns QueryResult[Incident] filtered by severity threshold and time window, with entity_count=0 in list view
- SentinelClient.get_incident_detail(number) returns incident with related alerts and entities, with entity_count populated from entity sub-query
- SentinelClient.get_incident_detail("name") returns incidents matching case-insensitive substring
- SentinelClient.query_alerts() returns QueryResult[Alert] filtered by severity and time range
- Metadata envelope present on every successful query result (total, query_ms, truncated)
- QueryError returned for failed queries with code, message, retry_possible
- All unit tests pass with mocked LogsQueryClient (no live Azure calls in tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-sentinel-data-access/02-01-SUMMARY.md`
</output>
