---
phase: 02-sentinel-data-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models.py
  - src/queries/__init__.py
  - src/queries/incidents.py
  - src/queries/alerts.py
  - src/projections.py
  - src/sentinel_client.py
  - tests/test_models.py
  - tests/test_queries.py
  - tests/test_sentinel_client.py
autonomous: true
requirements: [QUERY-01, QUERY-02, QUERY-03]

must_haves:
  truths:
    - "query_incidents() returns Incident dataclasses filtered by severity threshold and time window, wrapped in metadata envelope"
    - "get_incident_detail() by number returns incident with related alerts and entities"
    - "get_incident_detail() by name (string) returns matching incidents via case-insensitive substring"
    - "query_alerts() returns Alert dataclasses filtered by severity and time range, wrapped in metadata envelope"
    - "Timestamps in results include human-readable relative strings (e.g. '2 hours ago')"
    - "Partial results set truncated=True in metadata and include partial_error message"
    - "Failed queries return QueryError with code, message, and retry_possible flag"
  artifacts:
    - path: "src/models.py"
      provides: "Dataclass definitions for Incident, Alert, TrendPoint, EntityCount, QueryMetadata, QueryResult, QueryError, plus format_relative_time utility"
      contains: "class Incident"
    - path: "src/queries/__init__.py"
      provides: "Template registry, severity_filter(), build_query(), TIME_WINDOWS, TEMPLATE_TIMEOUTS"
      exports: ["TEMPLATE_REGISTRY", "severity_filter", "build_query", "TIME_WINDOWS"]
    - path: "src/queries/incidents.py"
      provides: "KQL templates for list_incidents, get_incident_by_number, get_incident_by_name, get_incident_alerts, get_incident_entities"
      contains: "TEMPLATES"
    - path: "src/queries/alerts.py"
      provides: "KQL templates for list_alerts"
      contains: "TEMPLATES"
    - path: "src/projections.py"
      provides: "Per-query-type field projection configs"
      contains: "PROJECTIONS"
    - path: "src/sentinel_client.py"
      provides: "SentinelClient class with query_incidents, get_incident_detail, query_alerts methods"
      contains: "class SentinelClient"
    - path: "tests/test_sentinel_client.py"
      provides: "Unit tests with mocked LogsQueryClient for incident and alert queries"
      contains: "def test_"
  key_links:
    - from: "src/sentinel_client.py"
      to: "src/queries/__init__.py"
      via: "import TEMPLATE_REGISTRY, build_query, severity_filter, TIME_WINDOWS"
      pattern: "from src\\.queries import"
    - from: "src/sentinel_client.py"
      to: "src/models.py"
      via: "import Incident, Alert, QueryResult, QueryError, QueryMetadata"
      pattern: "from src\\.models import"
    - from: "src/sentinel_client.py"
      to: "src/projections.py"
      via: "import PROJECTIONS for post-query field filtering"
      pattern: "from src\\.projections import"
    - from: "src/queries/__init__.py"
      to: "src/queries/incidents.py"
      via: "merges incidents.TEMPLATES into TEMPLATE_REGISTRY"
      pattern: "from src\\.queries import incidents"
---

<objective>
Build the data model layer, KQL template registry, projection configs, and SentinelClient with incident and alert query methods. This is the foundational infrastructure for all Sentinel data access.

Purpose: Establish the complete query pipeline -- from KQL templates through parameter substitution to typed dataclass results wrapped in metadata envelopes. Incident and alert queries cover the three most common SOC analyst use cases.

Output: src/models.py, src/queries/ package, src/projections.py, src/sentinel_client.py with incident/alert methods, and comprehensive unit tests.
</objective>

<execution_context>
@C:/Users/AlexSandstrom/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/AlexSandstrom/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sentinel-data-access/02-RESEARCH.md
@.planning/phases/02-sentinel-data-access/02-CONTEXT.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/config.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data models, KQL template registry, and projection configs</name>
  <files>
    src/models.py
    src/queries/__init__.py
    src/queries/incidents.py
    src/queries/alerts.py
    src/projections.py
    tests/test_models.py
    tests/test_queries.py
  </files>
  <action>
Create the foundational data layer for all Sentinel queries. This task builds the types, templates, and configuration that the SentinelClient will consume.

**src/models.py** -- Define all dataclasses and utilities:
- `QueryMetadata(total: int, query_ms: float, truncated: bool, partial_error: str | None = None)` -- metadata envelope
- `QueryResult(metadata: QueryMetadata, results: list[Any])` with `to_dict()` that serializes results recursively
- `QueryError(code: str, message: str, retry_possible: bool)` with `to_dict()`
- `Incident` dataclass with fields: `number` (int), `title` (str), `severity` (str), `status` (str), `created_time` (datetime), `last_modified_time` (datetime), `description` (str, default=""), `owner` (str, default=""), `alert_count` (int, default=0), `closed_time` (datetime | None), `first_activity_time` (datetime | None), `last_activity_time` (datetime | None), `incident_url` (str, default=""), `classification` (str, default=""), `classification_reason` (str, default=""), `labels` (list[str] | None, default=None), `created_time_ago` (str, default=""), `last_modified_time_ago` (str, default=""). Include `to_dict()` that converts datetimes to ISO strings.
- `Alert` dataclass with fields: `name` (str), `display_name` (str), `severity` (str), `status` (str), `time_generated` (datetime), `description` (str, default=""), `tactics` (str, default=""), `techniques` (str, default=""), `provider_name` (str, default=""), `compromised_entity` (str, default=""), `system_alert_id` (str, default=""), `time_generated_ago` (str, default=""). Include `to_dict()`.
- `TrendPoint(timestamp: datetime, count: int, severity: str = "")` with `to_dict()`
- `EntityCount(entity_type: str, entity_name: str, count: int)` with `to_dict()`
- `format_relative_time(dt: datetime) -> str` utility: "just now" (<60s), "N minutes ago", "N hours ago", "yesterday at H:MM AM/PM", "N days ago" (<7d), "Mon DD, YYYY" (>=7d). Handle naive datetimes by assuming UTC. Use `%I:%M %p` for cross-platform compatibility (not `%-I` which fails on Windows).

**src/queries/__init__.py** -- Central registry and utilities:
- `SEVERITY_ORDER = ["Informational", "Low", "Medium", "High"]` -- NO Critical (confirmed by research)
- `severity_filter(min_severity: str = "Informational") -> str` -- returns KQL-safe comma-separated string of severities at or above threshold. Invalid severity defaults to all (index 0). Example: `severity_filter("Medium")` -> `"'Medium','High'"`
- `TIME_WINDOWS` dict mapping window names to `{"timespan": timedelta, "kql_ago": str}`. Include: `last_1h`, `last_24h`, `last_3d`, `last_7d`, `last_14d`, `last_30d` (per research discretionary recommendation).
- `DEFAULT_LIMITS` dict with per-query-type defaults: `incident_list: 20`, `alert_list: 20`, `incident_detail_alerts: 50`, `alert_trend: 365`, `top_entities: 10`. `MAX_LIMITS` dict with hard caps: `incident_list: 100`, `alert_list: 100`, `incident_detail_alerts: 200`, `alert_trend: 365`, `top_entities: 50`.
- `TEMPLATE_TIMEOUTS` dict: 60s for simple queries (list_incidents, get_incident_by_number, get_incident_by_name, list_alerts, get_incident_alerts, get_incident_entities), 180s for aggregation queries (alert_trend, alert_trend_total, top_entities). `DEFAULT_TIMEOUT = 60`.
- `build_query(template_name: str, **params) -> str` -- looks up template in `TEMPLATE_REGISTRY`, validates all required placeholders are provided, applies defaults, calls `.format(**params)` for substitution. Raises `ValueError` for unknown template or missing required params.
- `TEMPLATE_REGISTRY` -- merged dict from all domain modules (incidents.TEMPLATES, alerts.TEMPLATES). trends and entities TEMPLATES will be added in Plan 02.

**src/queries/incidents.py** -- KQL templates dict `TEMPLATES`:
- `list_incidents`: Query SecurityIncident with `ago({time_range})` filter, `summarize arg_max(LastModifiedTime, *) by IncidentNumber` for dedup, `Severity in ({severity_filter})`, project all needed fields (IncidentNumber, Title, Severity, Status, CreatedTime, LastModifiedTime, Owner, AlertIds, Description, FirstActivityTime, LastActivityTime), order by CreatedTime desc, `take {limit}`.
- `get_incident_by_number`: Filter by `IncidentNumber == {incident_number}`, dedup with arg_max, project full detail fields including ClosedTime, Labels, Classification, ClassificationReason, IncidentUrl, AlertIds.
- `get_incident_by_name`: Dedup first, then `Title contains "{incident_name}"`, project full detail fields, `take {limit}`.
- `get_incident_alerts`: Use `let` statement to get AlertIds from incident by number, `mv-expand AlertId = AlertIds`, join to SecurityAlert via SystemAlertId, project alert fields.
- `get_incident_entities`: Same let statement for AlertIds, join to SecurityAlert, `parse_json(Entities)`, `mv-expand Entity`, extract EntityType and EntityName with `case()` for account/ip/host/url/file types, `distinct EntityType, EntityName`.

**src/queries/alerts.py** -- KQL templates dict `TEMPLATES`:
- `list_alerts`: Query SecurityAlert with `ago({time_range})`, `AlertSeverity in ({severity_filter})` (NOTE: use `AlertSeverity` NOT `Severity` -- critical pitfall from research), project AlertName, DisplayName, AlertSeverity, Status, TimeGenerated, Description, Tactics, Techniques, ProviderName, CompromisedEntity, SystemAlertId, order by TimeGenerated desc, `take {limit}`.

**src/projections.py** -- Define `PROJECTIONS` dict keyed by view name:
- `incident_list`: number, title, severity, status, created_time, alert_count, last_modified_time, created_time_ago, last_modified_time_ago
- `incident_detail`: number, title, severity, status, description, created_time, last_modified_time, closed_time, owner, alert_count, labels, classification, classification_reason, first_activity_time, last_activity_time, incident_url, created_time_ago, last_modified_time_ago
- `alert_list`: name, display_name, severity, status, time_generated, tactics, provider_name, compromised_entity, time_generated_ago
- Define `apply_projection(data: dict, view: str) -> dict` helper that filters a dict to only include keys present in the projection for the given view. Returns unmodified dict if view not found (defensive).

**tests/test_models.py** -- Test dataclass serialization:
- Test Incident.to_dict() converts datetimes to ISO strings
- Test QueryResult.to_dict() serializes nested Incident results
- Test QueryError.to_dict()
- Test format_relative_time() with: just now, minutes ago, hours ago, yesterday, days ago, older dates

**tests/test_queries.py** -- Test template registry and builder:
- Test severity_filter() for each threshold level (Informational through High)
- Test severity_filter() with invalid input defaults to all severities
- Test build_query() renders a template with correct parameter substitution
- Test build_query() raises ValueError for unknown template name
- Test build_query() raises ValueError for missing required parameters
- Test TIME_WINDOWS contains expected keys and correct timedelta/kql_ago pairs
- Test TEMPLATE_REGISTRY contains all expected template names
  </action>
  <verify>
Run `pytest tests/test_models.py tests/test_queries.py -v` -- all tests pass.
Run `python -c "from src.models import Incident, Alert, QueryResult, QueryError; print('models OK')"` -- imports succeed.
Run `python -c "from src.queries import TEMPLATE_REGISTRY, build_query, severity_filter, TIME_WINDOWS; print(len(TEMPLATE_REGISTRY), 'templates')"` -- prints template count.
Run `python -c "from src.projections import PROJECTIONS, apply_projection; print(len(PROJECTIONS), 'projections')"` -- imports succeed.
  </verify>
  <done>
All dataclasses defined with to_dict() serialization. KQL template registry contains 6 templates (list_incidents, get_incident_by_number, get_incident_by_name, get_incident_alerts, get_incident_entities, list_alerts). build_query() validates and renders templates. severity_filter() implements threshold model. TIME_WINDOWS maps 6 predefined windows. Projections define 3 views. All model and query tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SentinelClient with incident and alert query methods</name>
  <files>
    src/sentinel_client.py
    tests/test_sentinel_client.py
  </files>
  <action>
Build the SentinelClient class that executes KQL templates via LogsQueryClient and returns typed results.

**src/sentinel_client.py** -- Full SentinelClient implementation:

`class SentinelClient`:
- `__init__(self, settings: Settings)`: Store `settings.sentinel_workspace_id`, create `DefaultAzureCredential()`, create `LogsQueryClient(credential)`. Accept optional `client` parameter for test injection (if provided, skip credential/client creation).
- Private `_execute_query(self, query: str, timespan: timedelta, server_timeout: int) -> tuple[list, bool, str | None, float]`: Call `self._client.query_workspace()` with `workspace_id`, `query`, `timespan`, `server_timeout`, `include_statistics=True`. Check `response.status`:
  - `LogsQueryStatus.SUCCESS`: Extract tables, compute query_ms from `response.statistics["query"]["executionTime"] * 1000` (handle missing stats gracefully), return `(tables, False, None, query_ms)`.
  - `LogsQueryStatus.PARTIAL`: Extract `response.partial_data`, `response.partial_error`, compute query_ms, return `(tables, True, f"{error.code}: {error.message}", query_ms)`.
  - Catch `HttpResponseError`: Return `QueryError` with `code=e.error.code` or `"http_error"`, `message=str(e)`, `retry_possible=True` for 429/5xx and `False` otherwise.
  - Catch general `Exception`: Return `QueryError` with `code="unknown"`, `message=str(e)[:500]`, `retry_possible=False`.

- Private `_parse_incidents(self, tables, is_detail: bool = False) -> list[Incident]`: Parse LogsTable rows into Incident dataclasses. Map Sentinel column names to dataclass fields: IncidentNumber->number, Title->title, Severity->severity, Status->status, CreatedTime->created_time, LastModifiedTime->last_modified_time, Description->description, AlertIds->alert_count (len of parsed JSON array), Owner->owner (extract from dynamic JSON: `json.loads(owner).get("assignedTo", "")` if string, else ""). Compute `created_time_ago` and `last_modified_time_ago` using `format_relative_time()`. Handle None/missing fields defensively. For detail view, also map: ClosedTime, Labels (parse JSON array), Classification, ClassificationReason, FirstActivityTime, LastActivityTime, IncidentUrl.

- Private `_parse_alerts(self, tables) -> list[Alert]`: Parse LogsTable rows into Alert dataclasses. Map: AlertName->name, DisplayName->display_name, AlertSeverity->severity (NOT Severity), Status->status, TimeGenerated->time_generated, Description->description, Tactics->tactics, Techniques->techniques, ProviderName->provider_name, CompromisedEntity->compromised_entity, SystemAlertId->system_alert_id. Compute `time_generated_ago`.

- Private `_parse_entities(self, tables) -> list[dict]`: Parse entity rows into simple dicts with `entity_type` and `entity_name` keys. (Used by get_incident_detail for incident entities.)

- `query_incidents(self, time_window="last_24h", min_severity="Informational", limit=20) -> QueryResult | QueryError`: Validate time_window in TIME_WINDOWS (return QueryError if invalid). Clamp limit to MAX_LIMITS["incident_list"]. Build query via `build_query("list_incidents", time_range=..., severity_filter=severity_filter(min_severity), limit=limit)`. Execute via `_execute_query`. Parse results. Apply projection "incident_list". Wrap in QueryResult with metadata.

- `get_incident_detail(self, incident_ref: int | str) -> QueryResult | QueryError`: If `incident_ref` is int, use "get_incident_by_number" template. If str, use "get_incident_by_name" template with limit=10. Execute incident query, parse as detail. Then execute "get_incident_alerts" and "get_incident_entities" for the incident number(s) found. Return composite result: `{"incidents": [...], "alerts": [...], "entities": [...]}` structure within QueryResult. Apply "incident_detail" projection to incidents.

- `query_alerts(self, time_window="last_24h", min_severity="Informational", limit=20) -> QueryResult | QueryError`: Same pattern as query_incidents but for alerts. Use "list_alerts" template. Parse with `_parse_alerts`. Apply "alert_list" projection.

**tests/test_sentinel_client.py** -- Unit tests with mocked LogsQueryClient:
- Create a `MockLogsTable` class that mimics LogsTable: has `.columns` (list of str) and `.rows` (list of MockRow). `MockRow` supports both index and column-name access.
- Create a `MockResponse` class with `.status`, `.tables`, `.statistics`, `.partial_data`, `.partial_error`.
- Create a `mock_sentinel_client` fixture that injects a mocked LogsQueryClient into SentinelClient (using the optional `client` parameter).
- Test `query_incidents()` returns QueryResult with correct Incident dataclasses and metadata envelope.
- Test `query_incidents()` with severity filter returns only matching severities in the KQL query string.
- Test `get_incident_detail()` by number returns incident with alerts and entities.
- Test `get_incident_detail()` by string name uses contains template.
- Test `query_alerts()` returns QueryResult with Alert dataclasses.
- Test partial results set `truncated=True` and include `partial_error` in metadata.
- Test HTTP error returns QueryError with appropriate code and retry_possible flag.
- Test invalid time_window returns QueryError.
- Test limit clamping to hard cap.
  </action>
  <verify>
Run `pytest tests/test_sentinel_client.py -v` -- all tests pass.
Run `pytest -v` -- all tests pass (including existing config tests and new model/query tests from Task 1).
Run `ruff check src/ tests/` -- no linting errors.
Run `python -c "from src.sentinel_client import SentinelClient; print('client OK')"` -- import succeeds.
  </verify>
  <done>
SentinelClient class implemented with query_incidents(), get_incident_detail(), and query_alerts() methods. Each method: validates parameters, builds KQL via template registry, executes via LogsQueryClient, parses LogsTable rows into typed dataclasses, applies projection, wraps in metadata envelope. Partial results handled with truncated flag. Errors returned as structured QueryError objects. All unit tests pass with mocked LogsQueryClient. No ruff linting errors.
  </done>
</task>

</tasks>

<verification>
1. `pytest -v` passes all tests (existing config tests + new model/query/client tests)
2. `ruff check src/ tests/` reports no errors
3. `python -c "from src.sentinel_client import SentinelClient; from src.models import Incident, Alert, QueryResult; from src.queries import TEMPLATE_REGISTRY; print(f'{len(TEMPLATE_REGISTRY)} templates registered')"` succeeds
4. All dataclass to_dict() methods produce JSON-serializable output
5. severity_filter("Medium") returns "'Medium','High'" (threshold model, no Critical)
6. build_query() raises ValueError for unknown templates and missing params
</verification>

<success_criteria>
- SentinelClient.query_incidents() returns QueryResult[Incident] filtered by severity threshold and time window
- SentinelClient.get_incident_detail(number) returns incident with related alerts and entities
- SentinelClient.get_incident_detail("name") returns incidents matching case-insensitive substring
- SentinelClient.query_alerts() returns QueryResult[Alert] filtered by severity and time range
- Metadata envelope present on every successful query result (total, query_ms, truncated)
- QueryError returned for failed queries with code, message, retry_possible
- All unit tests pass with mocked LogsQueryClient (no live Azure calls in tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-sentinel-data-access/02-01-SUMMARY.md`
</output>
